# Apprenez par vous-m√™me la science informatique

> Ce document est une traduction de [TeachYourselfCS](https://teachyourselfcs.com/), √©crit par [Ozan Onay](https://twitter.com/oznova_) et [Myles Byrne](https://twitter.com/quackingduck).

> Ceci est une traduction de la version originale mise √† jour en mai 2020.

Si vous √™tes un ing√©nieur autodidacte ou que vous avez particip√© √† un _bootcamp_, vous vous devez d'apprendre la science informatique. Heureusement, vous pouvez vous instruire dans ce domaine sans y passer des ann√©es et sans d√©penser une petite fortune dans un dipl√¥me.

Si les ressources disponibles sont nombreuses, toutes ne se valent pas. Vous n'avez pas besoin d'encore une autre liste de "200+ cours en ligne gratuits". Vous avez besoin de r√©ponses aux questions suivantes:

- **Quelles disciplines** devriez-vous apprendre, et pourquoi ?

- Quel est **le meilleur livre ou la meilleure s√©rie de vid√©os** pour chacune de ces disciplines ?

Ce guide est notre tentative de r√©pondre d√©finitivement √† toutes ces questions.

## TL;DR (en bref)


√âtudiez l'ensemble des neufs domaines suivants, plus ou moins dans l'ordre pr√©sent√©, √† l'aide du manuel ou des vid√©os propos√©es (mais id√©alement les deux). Comptez 100 √† 200 heures pour chaque sujet, puis revoyez vos pr√©f√©r√©s tout au long de votre carri√®re üöÄ.

| Domaine | Pourquoi l'√©tudier ? | Livre | Vid√©os |
| --------| -------------------- | ----- | ------ |
| **Programmation** | Ne soyez pas la personne qui n'a "jamais vraiment bien compris" quelque chose comme la r√©cursion. | _Structure and Interpretation of Computer Programs_ | Berkeley CS 61A par Brian Harvey|
| **Architecture des ordinateurs** | Si vous n'avez pas une repr√©sentation mentale solide de la mani√®re dont fonctionne un ordinateur, toutes vos abstractions de haut niveau en seront fragilis√©es. | _Computer Systems: A Programmer's Perspective_ | Berkeley CS 61C|
| **Algorithmes et structures de donn√©es** | Si vous ne savez pas comment utiliser des structures de donn√©es omnipr√©sentes, comme des piles, des queues, des arbres ou des graphes, alors vous ne serez pas en mesure de r√©soudre des probl√®mes difficiles. | _The Algorithm Design Manual_ | Les cours de Steven Skiena |
| **Math√©matiques pour l'informatique** | La science informatique est fondamentalement une branche d√©riv√©e des math√©matiques appliqu√©es aussi apprendre les math√©matiques vous donnera un avantage comp√©titif. | _Mathematics for Computer Science_ | MIT 6.042J par Tom Leighton |
| **Syst√®me d'exploitation** | La plupart du code que vous √©crivez est ex√©cut√© par un syst√®me d'exploitation donc vous devriez savoir comment celui-ci interagit. | _Operating Systems: Three Easy Pieces_ | Berkeley CS 162 |
| **R√©seaux informatiques** | Internet s'est av√©r√© √™tre une grosse affaire: comprenez comment il fonctionne pour d√©ployer son plein potentiel. | _Computer Networking: A Top-Down Approach_ | Stanford CS 144 |
| **Bases de donn√©es** | Les donn√©es sont au coeurs des programmes les plus importants, or peu de personnes comprennent comment les syst√®mes de bases de donn√©es fonctionnent r√©ellement. | _Readings in Database Systems_ | Berkeley CS 186 par Joe Hellerstein |
| **Langages et compilateurs** | Si vous comprenez comment les langages et les compilateurs fonctionnent, votre code sera meilleur et il vous sera plus ais√© d'apprendre de nouveaux langages. | _Crafting Interpreters_ | Le cours d'Alex Aiken sur edX |
| **Syst√®mes distribu√©s** | De nos jours, la plupart des syst√®mes sont distribu√©s. | _Designing Data-Intensive Applications_ de Martin Kleppmann | MIT 6.824|
